# Unit 0: 总览 | Overview [未完成]

!!! info "导语"
    本单元主要有两个任务：
    
    1. 对操作系统进行一个较为抽象的介绍，同时建立起整门课程的框架，方便读者在之后的学习过程中能有一个比较总体的认识，能带着目的去学习具体的知识；
    2. 介绍一些比较基础的内容，或是一些比较琐碎、仅需了解的内容；

    由于课本的 Overview 写得非常一言难尽，所以我在啃完后进行了一些整理，你可以在[这里](https://www.yuque.com/isshikixiu/codes/dvlbpqigbod5xcby)找到我整理过程中完成的思维导图，不过这个思维导图更多的是提供框架性的认知，具体到每个叶子节点的内容建议还是以本文为主。此外，本文很多观点具有比较强烈的个人理解色彩，如果你对其中的论断抱有异议，欢迎讨论！

    本文的主线是不断细化我们看待操作系统的粒度， 

在正式开始核心内容的学习之前，我想先做一点说明，也算是一点关于学习操作系统的经验之谈。

!!! key-point "“定义不存在了”"
        区别于自然科学的研究对象，操作系统作为一个彻彻底底的人造物，其很多概念都很难界定一个明确的界限，这也正是我在学习操作系统的过程中遇到的最首要的问题。我会尽力给出我认为更精确的定义，但这个问题仍然存在，所以我们尽量只围绕定义的中心进行学习。

---

## 操作系统概述

!!! info ""
    本节主要将操作系统当作一个不可拆分的单位，来讨论什么是操作系统。

### 何为操作系统

整门课程我们需要解决的第一个问题，显然是什么是**操作系统(Operating System)OS**。接下来我将从两个方面简述何为操作系统。

!!! section "① 从职能上看"

    ![Abstract view of the components of a computer system.](img/1.png){width=40% align=right}

    <u>从其**职能**上看，我认为操作系统是一个**资源管理系统**</u>。

    右图描述了计算机系统的抽象层级：自上而下，用户通过应用程序解决问题，应用程序向操作系统请求计算机**资源**；自下而上，计算机硬件为软件（包括 OS）提供了物质基础，本质上，硬件提供了计算机**资源**。

    操作系统作为中间层，向上为用户程序分配易用的资源，向下直接操作硬件资源的，在这个过程中，操作系统还需要**公平**、**高效**地解决资源之间的冲突问题等等。

    它就好像药房柜台，各种药品就好像计算机资源，病人提供处方，柜台收到请求（[系统调用](TODO:)）后处理请求，并千辛万苦（具体会遇到什么问题我们会在之后的内容中学到）替你准备好你需要的资源，完成你的请求。

    具体来说，操作系统管理的**资源**有这些：① CPU，由于 CPU 的一个核(core)在特定时刻只能处理一件事，所以“CPU 能够为我所用”是一个非常重要的资源；② 内存，执行程序离不开内存，用户程序自然也需要占用一定的内存来解决问题；③ I/O 设备，打印机不能同时打印毛概历年卷和转专业申请表；④………粗略的来说，本课程之后的内容基本上都是围绕要如何维护和操作各种资源而展开的。

!!! section "② 从存在上看"

    <u>从其存在来看，操作系统本质上还是一个**软件程序**，是一个不停运行着的，用来执行用户程序的软件</u>。这个角度的本质同时反应了操作系统最初存在的目的，为了提高计算机资源的利用效率，我们需要一个程序来自动化“让计算机完成一系列特定任务”这件事，而为了实现这个自动化，这个程序也需要成为计算机硬件的“代理人”，掌握硬件的所有资源，并且这个“代理人”还得想方法让自己好好“活着”。

    操作系统中最基础最中央的部分是**内核(kernel)**，要给出 kernel 的精确定义很难，这与操作系统设计的结构有关（参考[宏内核](TODO:)和[微内核](TODO:)），它最明显的一个特点就是自计算机开机后就不停在运行。OS 和 kernel 的关系就好像笔记本电脑和它的主板，如果将 OS 中的其他部分除去，kernel 仍然自洽，仍然具备它应有的内在的功能，比如它仍然具备对资源进行调度的能力，只不过它可能拿不到能让它调度的资源。我在这里避免谈到 OS 和 kernel 的区别，因为这实在难以说清，甚至在之后的内容中，我都会用 OS 来代替 kernel 的概念。

至此，我们从两个方面了解了什么是操作系统，现在用一句课本上的话来做总结。

> The common functions of controlling and allocating resources are then brought together into one piece of software: the operating system. --*Operating System Concepts (10^th^ edition)*

---

### 操作系统的设计目标

现在我们知道操作系统是什么东西了，那么在此基础上我们挖掘一下，怎样才算一个好的操作系统，也就是操作系统的发展方向，而在这个过程中，我也会简单提及一些我们之后会设计的内容，以供参考。

!!! note ""
    首先，操作系统本身需要有较好的可靠性，也就是我们之前提到的，这个“代理人”要尽可能让自己好好“活着”。一方面它需要有良好的异常处理机制（通过[#中断机制](TODO:)实现），这个“代理人”需要有强健的体魄，不能一刮风它就病倒了；另一方面它需要有权限管理系统（[#特权模式](TODO:)），以屏蔽来自用户程序的危险行为，用户可以向“柜台”索取抗生素，但是用户索取库房钥匙时，合格的“柜台”显然不能答应这个请求。

!!! note ""

    其次，操作系统需要有较好的易用性，它需要向用户提供简便的服务以请求系统资源，毕竟操作系统的目的之一就是方便用户使用系统资源——这意味着我们的“代理人”得是个好交流的人，而用户程序调用操作系统资源的途径是[系统调用](TODO:)。

    > 宽泛一点来讲，操作系统为我们提供了命令接口和程序接口，有些地方也会提到图形用户接口(Graphical User Interface)GUI，以及命令行接口(Command Line Interface)CLI，但是我个人不是很喜欢这个分类。

!!! note ""

    当然，操作系统需要是高效的，从最早的批处理系统到现在的分时系统（[#操作系统的任务执行设计](#操作系统的任务执行设计)），CPU 的利用率在不断提升，周转时间也在不断缩短，如今的操作系统通过分时技术也实现了体感上的并行，提高效率的同时也提高了用户体验。

!!! note ""

    还有一点不容忽视的是操作系统的（一定程度上的）**公平性**，在 [Unit 1: 进程管理](Unit1.md)中我们会了解到，多进程语境下有大量的冲突问题需要解决，而我们在处理这些冲突问题的时候，可能会出现**饥饿(Starvation)**（具体是什么请参考下一单元），而操作系统要做的就是避免饥饿的出现，就好像繁忙时段的电梯，我们不能因为二楼流量很大就不管三楼以上的人。

!!! note ""

    上述目标大多是针对使用者而言的，那么对于开发者来说，操作系统的可扩展性、易维护性等也是非常重要的。不同的设计思路造就了不同的操作系统结构，各种设计也各自有各自的主战场，关于这些内容，我们会在[#操作系统的结构设计](#操作系统的结构设计)这一部分更详细地介绍。

上述观点并不全面也不一定完全正确，有一大部分都是我的个人理解，请读者辨证地看待，如果有错误请务必告诉我！

---

## 操作系统的整体设计

!!! info ""
    本节主要就一些关于操作系统整体设计的问题做一些讨论，从一个相对比较高的角度谈一谈一些顶层设计。

### 计算机系统架构

虽然操作系统本身是软件，但是它毕竟是与硬件紧密关联的，所以我们还是会涉及到一些关于硬件的内容，这里简单涉及一些关于计算机系统架构的内容。

???+ extra "概念辨析"
    <center> <table>
        <thead> 
            <tr>    <th>名词</th>               <th>定位</th>                      </tr> 
        </thead>
        <tbody> 
            <tr>    <td>CPU</td>                <td>执行指令的硬件</td>             </tr> 
            <tr>    <td>Core</td>               <td>CPU 的基础计算单元</td>         </tr>
            <tr>    <td>Multi-core</td>         <td>一个 CPU 上有多个 core</td>     </tr> 
            <tr>    <td>Processor</td>          <td>包含一个或多个 CPU 的芯片</td>   </tr>
            <tr>    <td>Multi-processor</td>    <td>多个 processor</td>            </tr> 
        </tbody>
    </table> </center>

根据处理器的数量和组织形式，我们这里介绍三种计算机系统架构：单处理器系统、多处理器系统、集群系统。

!!! section "① 单处理器系统(Single-Processor System)"

    书中给出的关于单处理器系统的定义是，有且仅有一个**通用处理器(general-purpose processor)**，并且这个 processor 只有一个核(core)。但它可以有若干**专用处理器(special-purpose processor)**，用来执行一些特定的指令，而这些专用处理器并不运行线程。

!!! section "② 多处理器系统(Multiprocessor System)"

    多处理器系统是指有多个**单核**通用处理器的系统，这些处理器共享一块主内存，它们通过总线或交换网络连接在一起。

    显而易见的是，增加了处理器的数量能够增加**吞吐量(throughput)**，即单位时间内处理的任务数量，但是这个增加并不是线性的，因为处理器之间的通信也需要时间，而且还会有一些额外的开销。

    ??? quote "相关阅读"
        - [对称多处理 | SMP](https://en.wikipedia.org/wiki/Symmetric_multiprocessing)；

        <center> ![Symmetric multiprocessing architecture.](img/3.png){width=50%} </center>
        > Symmetric multiprocessing architecture.

        - [非一致内存访问 | NUMA](https://en.wikipedia.org/wiki/Non-uniform_memory_access)；
        
        <center> ![NUMA multiprocessing architecture.](img/5.png){width=50%} </center>
        > NUMA multiprocessing architecture.

        但是 multi-core 的设计在速度和效能上都更胜一筹，因为 on-chip 的通信比 between-chip 的通信更快，而且更省电。

!!! section "③ 集群系统(Cluster System)"

    集群系统通过冗余实现高可用服务，通过并行实现高性能计算，它是由多个各自独立的计算机系统作为节点(node)，通过高速通信网络互相连接形成的。

    集群也分对称和不对称两种，对称集群的各个节点互相监督，而不对称的集群则存在一种类似“替补”的东西，由“替补”去监督工作中的节点，当工作中的节点出现了问题，就由“替补”来接替它的工作。

---

### 操作系统的任务执行设计

前面我们说过，操作系统被用来「自动化“让计算机完成一系列特定任务”」的。一开始这件事比较简单，只需要像队列一样，一个一个的执行就行，但是慢慢的随着计算机应用范围的扩大以及各种需求的出现，这种设计就不太合理了。按照发展阶段演进，我们划分出两个阶段三个设计：**单道批处理(Batch Processing Systems)**、**多道批处理(Multiprogramming Batch Processing Systems)**和**分时系统(Time Sharing Systems)**。其中后两者分别实现了**多道程序设计(Multiprogramming)**和**多任务处理(Multitasking)**。

!!! section "批处理系统阶段"

    !!! section "单道批处理阶段"
        sth.

    !!! section "多道批处理阶段"
        sth.

!!! section "分时处理系统阶段"
    sth.


---

### 操作系统的结构设计




---

## 操作系统的运行原理


---

## 关键点总结